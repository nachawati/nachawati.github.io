<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Dr. Mohamad Omar Nachawati Blog</title>
        <link>https://nachawati.me/blog</link>
        <description>Dr. Mohamad Omar Nachawati Blog</description>
        <lastBuildDate>Thu, 17 Aug 2023 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Workaround for Differences Between Node.js and Web Tree-sitter APIs]]></title>
            <link>https://nachawati.me/blog/2023/08/17/tree-sitter-api-differences-node-and-web-workaround</link>
            <guid>https://nachawati.me/blog/2023/08/17/tree-sitter-api-differences-node-and-web-workaround</guid>
            <pubDate>Thu, 17 Aug 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Tree-sitter is a great tool for building incremental and error-tolerant parsers for use in compilers, IDEs and code analyzers, which can also run directly in the browser. Unlike ANTLR, which is a popular open-source LL(*) parser generator, tree-sitter is a GLR parser generator that's similar but more powerful than the LALR parser generator YACC that we all were forced to learn back in CS 440 ðŸ˜….]]></description>
            <content:encoded><![CDATA[<p><a href="https://tree-sitter.github.io/tree-sitter/" target="_blank" rel="noopener noreferrer">Tree-sitter</a> is a great tool for building incremental and error-tolerant parsers for use in compilers, IDEs and code analyzers, which can also run directly in the browser. Unlike <a href="https://www.antlr.org/" target="_blank" rel="noopener noreferrer">ANTLR</a>, which is a popular open-source <a href="https://en.wikipedia.org/wiki/LL_parser" target="_blank" rel="noopener noreferrer">LL(*) parser</a> generator, tree-sitter is a <a href="https://en.wikipedia.org/wiki/GLR_parser" target="_blank" rel="noopener noreferrer">GLR parser</a> generator that's similar but more powerful than the <a href="https://en.wikipedia.org/wiki/LALR_parser" target="_blank" rel="noopener noreferrer">LALR parser</a> generator <a href="https://en.wikipedia.org/wiki/Yacc" target="_blank" rel="noopener noreferrer">YACC</a> that we all were forced to learn back in <a href="https://cs.gmu.edu/~white/CS440/" target="_blank" rel="noopener noreferrer">CS 440</a> ðŸ˜….</p><p>It's also nice that tree-sitter is open-source, unlike the closed-source <a href="https://www.bottlecaps.de/rex/" target="_blank" rel="noopener noreferrer">REx Parser Generator</a> that I used to generate the <a href="https://www.jsoniq.org/" target="_blank" rel="noopener noreferrer">JSONiq</a> parser for the <a href="https://github.com/nachawati/unity" target="_blank" rel="noopener noreferrer">Unity DGMS</a> analytics engine (from the <a href="https://www.jsoniq.org/grammars/jq++.ebnf" target="_blank" rel="noopener noreferrer">ebnf grammar</a>). I guess it can be a bit disquieting for a project to depend on <a href="https://twitter.com/__Gunther__" target="_blank" rel="noopener noreferrer">Gunther Rademacher</a> to continuing maintaining his REx web service ðŸ˜¬.</p><p>Recently, however, I ran into a problem with tree-sitter when trying to reuse TypeScript code for both Node.js and the Web. Although both of these tree-sitter API implementations can be called separately from TypeScript (or JavaScript), slight differences prevents seamlessly interchanging them in a cross-platform build. Until this problem is properly fixed, I've developed a simple workaround that provides a unified tree-sitter API for both Node.js and the Web.</p><p>To use it, simply import this <a href="https://gist.github.com/nachawati/351cba7c0b9adff2b75a2fafe3e73ac3#file-tree-sitter-api-ts" target="_blank" rel="noopener noreferrer">Gist</a> in any common module that processes tree-sitter <code>SyntaxNode</code>s. Please note that this workaround does not eliminate the need for Node.js- and Web- specific loading and initialization of the tree-sitter API and languages.</p><iframe width="100%" frameborder="0" id="gist-351cba7c0b9adff2b75a2fafe3e73ac3"></iframe>]]></content:encoded>
            <author>mnachawa@gmail.com (Mohamad Omar Nachawati)</author>
            <category>node</category>
            <category>parsing</category>
            <category>wasm</category>
            <category>web</category>
            <category>webassembly</category>
        </item>
        <item>
            <title><![CDATA[Compiling CasADi to WebAssembly]]></title>
            <link>https://nachawati.me/blog/2023/08/08/compiling-casadi-webassembly</link>
            <guid>https://nachawati.me/blog/2023/08/08/compiling-casadi-webassembly</guid>
            <pubDate>Tue, 08 Aug 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Today I revisited CasADi to see if I could use emscripten to compile it to a WebAssembly and run it inside of a Web browser. CasADi is an awesome tool for performing symbolic computation and automatic differentiation, among other things. It also provides interfaces to popular open-source solvers, such as the MINLP solver BONMIN.]]></description>
            <content:encoded><![CDATA[<p>Today I revisited <a href="https://web.casadi.org/" target="_blank" rel="noopener noreferrer">CasADi</a> to see if I could use <a href="https://emscripten.org/" target="_blank" rel="noopener noreferrer">emscripten</a> to compile it to a WebAssembly and run it inside of a Web browser. CasADi is an awesome tool for performing <a href="https://en.wikipedia.org/wiki/Computer_algebra" target="_blank" rel="noopener noreferrer">symbolic computation</a> and <a href="https://en.wikipedia.org/wiki/Automatic_differentiation" target="_blank" rel="noopener noreferrer">automatic differentiation</a>, among other things. It also provides interfaces to popular open-source solvers, such as the MINLP solver <a href="https://www.coin-or.org/Bonmin/" target="_blank" rel="noopener noreferrer">BONMIN</a>.</p><p>I had previously used CasADi during my PhD to implement a grey-box algorithmic framework that I had designed and aptly named GreyOpt (<a href="https://www.scitepress.org/PublishedPapers/2021/103501/103501.pdf" target="_blank" rel="noopener noreferrer">paper</a>, <a href="http://mason.gmu.edu/~mnachawa/icores2021-slides.pdf" target="_blank" rel="noopener noreferrer">slides</a>). I also used CasADi for implementing the main backend of <a href="https://github.com/nachawati/unity" target="_blank" rel="noopener noreferrer">Unity DGMS</a>, an open-source JSONiq analytics engine. I thought it would be interesting to see if at least some functionality could be easily ported to run directly in the browser.</p><p>It was fairly easy to add a new executable target in <a href="https://cmake.org/" target="_blank" rel="noopener noreferrer">CMAKE</a>, along with a simple C API that wrapped some functions for constructing symbolic variables and for performing basic symbolic arithmetic. I initially got some compilation errors stemming from an issue with some preprocessor directives that conditionally enabled the <code>pack</code> and <code>unpack</code> methods for <code>unsigned int&amp;</code> arguments based on the value of <code>SIZE_MAX</code> (WASM support is currently only 32-bit).</p><p>After resolving those errors, the build and linking of the CasADi WebAssembly completed successfully. Now I can use CasADi to do computer algebra in Chromium ;-)</p>]]></content:encoded>
            <author>mnachawa@gmail.com (Mohamad Omar Nachawati)</author>
            <category>casadi</category>
            <category>wasm</category>
            <category>webassembly</category>
        </item>
    </channel>
</rss>