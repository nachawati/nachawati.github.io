<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://nachawati.me/blog</id>
    <title>Dr. Mohamad Omar Nachawati Blog</title>
    <updated>2023-08-17T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://nachawati.me/blog"/>
    <subtitle>Dr. Mohamad Omar Nachawati Blog</subtitle>
    <icon>https://nachawati.me/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Workaround for Differences Between Node.js and Web Tree-sitter APIs]]></title>
        <id>https://nachawati.me/blog/2023/08/17/tree-sitter-api-differences-node-and-web-workaround</id>
        <link href="https://nachawati.me/blog/2023/08/17/tree-sitter-api-differences-node-and-web-workaround"/>
        <updated>2023-08-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Tree-sitter is great tool for building incremental and error-tolerant parsers for use in compilers, IDEs and code analyzers, which can also run directly in the browser. Unlike ANTLR, which is a popular open-source LL(*) parser generator, tree-sitter is a GLR parser generator that's similar but more powerful than the LALR parser generator YACC that we all were forced to learn back in CS 440 ðŸ˜….]]></summary>
        <content type="html"><![CDATA[<p><a href="https://tree-sitter.github.io/tree-sitter/" target="_blank" rel="noopener noreferrer">Tree-sitter</a> is great tool for building incremental and error-tolerant parsers for use in compilers, IDEs and code analyzers, which can also run directly in the browser. Unlike <a href="https://www.antlr.org/" target="_blank" rel="noopener noreferrer">ANTLR</a>, which is a popular open-source <a href="https://en.wikipedia.org/wiki/LL_parser" target="_blank" rel="noopener noreferrer">LL(*) parser</a> generator, tree-sitter is a <a href="https://en.wikipedia.org/wiki/GLR_parser" target="_blank" rel="noopener noreferrer">GLR parser</a> generator that's similar but more powerful than the <a href="https://en.wikipedia.org/wiki/LALR_parser" target="_blank" rel="noopener noreferrer">LALR parser</a> generator <a href="https://en.wikipedia.org/wiki/Yacc" target="_blank" rel="noopener noreferrer">YACC</a> that we all were forced to learn back in <a href="https://cs.gmu.edu/~white/CS440/" target="_blank" rel="noopener noreferrer">CS 440</a> ðŸ˜….</p><p>It's also nice that tree-sitter is open-source, unlike the closed-source <a href="https://www.bottlecaps.de/rex/" target="_blank" rel="noopener noreferrer">REx Parser Generator</a> that I used to generate the <a href="https://www.jsoniq.org/" target="_blank" rel="noopener noreferrer">JSONiq</a> parser for the <a href="https://github.com/nachawati/unity" target="_blank" rel="noopener noreferrer">Unity DGMS</a> analytics engine (from the <a href="https://www.jsoniq.org/grammars/jq++.ebnf" target="_blank" rel="noopener noreferrer">ebnf grammar</a>). I guess it can be a bit disquieting for a project to depend on <a href="https://twitter.com/__Gunther__" target="_blank" rel="noopener noreferrer">Gunther Rademacher</a> to continuing maintaining his REx web service ðŸ˜¬.</p><p>Recently, however, I ran into a problem with tree-sitter when trying to reuse TypeScript code for both Node.js and the Web. Although both of these tree-sitter API implementations can be called separately from TypeScript (or JavaScript), slight differences prevents seamlessly interchanging them in a cross-platform build. Until this problem is properly fixed, I've developed a simple workaround that provides a unified tree-sitter API for both Node.js and the Web.</p><p>To use it, simply import this <a href="https://gist.github.com/nachawati/351cba7c0b9adff2b75a2fafe3e73ac3#file-tree-sitter-api-ts" target="_blank" rel="noopener noreferrer">Gist</a> in any common module that processes tree-sitter <code>SyntaxNode</code>s. Please note that this workaround does not eliminate the need for Node.js- and Web- specific loading and initialization of the tree-sitter API and languages.</p><iframe width="100%" frameborder="0" id="gist-351cba7c0b9adff2b75a2fafe3e73ac3"></iframe>]]></content>
        <author>
            <name>Mohamad Omar Nachawati</name>
            <email>mnachawa@gmail.com</email>
            <uri>https://nachawati.me</uri>
        </author>
        <category label="node" term="node"/>
        <category label="parsing" term="parsing"/>
        <category label="wasm" term="wasm"/>
        <category label="web" term="web"/>
        <category label="webassembly" term="webassembly"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Compiling CasADi to WebAssembly]]></title>
        <id>https://nachawati.me/blog/2023/08/08/compiling-casadi-webassembly</id>
        <link href="https://nachawati.me/blog/2023/08/08/compiling-casadi-webassembly"/>
        <updated>2023-08-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Today I revisited CasADi to see if I could use emscripten to compile it to a WebAssembly and run it inside of a Web browser. CasADi is an awesome tool for performing symbolic computation and automatic differentiation, among other things. It also provides interfaces to popular open-source solvers, such as the MINLP solver BONMIN.]]></summary>
        <content type="html"><![CDATA[<p>Today I revisited <a href="https://web.casadi.org/" target="_blank" rel="noopener noreferrer">CasADi</a> to see if I could use <a href="https://emscripten.org/" target="_blank" rel="noopener noreferrer">emscripten</a> to compile it to a WebAssembly and run it inside of a Web browser. CasADi is an awesome tool for performing <a href="https://en.wikipedia.org/wiki/Computer_algebra" target="_blank" rel="noopener noreferrer">symbolic computation</a> and <a href="https://en.wikipedia.org/wiki/Automatic_differentiation" target="_blank" rel="noopener noreferrer">automatic differentiation</a>, among other things. It also provides interfaces to popular open-source solvers, such as the MINLP solver <a href="https://www.coin-or.org/Bonmin/" target="_blank" rel="noopener noreferrer">BONMIN</a>.</p><p>I had previously used CasADi during my PhD to implement a grey-box algorithmic framework that I had designed and aptly named GreyOpt (<a href="https://www.scitepress.org/PublishedPapers/2021/103501/103501.pdf" target="_blank" rel="noopener noreferrer">paper</a>, <a href="http://mason.gmu.edu/~mnachawa/icores2021-slides.pdf" target="_blank" rel="noopener noreferrer">slides</a>). I also used CasADi for implementing the main backend of <a href="https://github.com/nachawati/unity" target="_blank" rel="noopener noreferrer">Unity DGMS</a>, an open-source JSONiq analytics engine. I thought it would be interesting to see if at least some functionality could be easily ported to run directly in the browser.</p><p>It was fairly easy to add a new executable target in <a href="https://cmake.org/" target="_blank" rel="noopener noreferrer">CMAKE</a>, along with a simple C API that wrapped some functions for constructing symbolic variables and for performing basic symbolic arithmetic. I initially got some compilation errors stemming from an issue with some preprocessor directives that conditionally enabled the <code>pack</code> and <code>unpack</code> methods for <code>unsigned int&amp;</code> arguments based on the value of <code>SIZE_MAX</code> (WASM support is currently only 32-bit).</p><p>After resolving those errors, the build and linking of the CasADi WebAssembly completed successfully. Now I can use CasADi to do computer algebra in Chromium ;-)</p>]]></content>
        <author>
            <name>Mohamad Omar Nachawati</name>
            <email>mnachawa@gmail.com</email>
            <uri>https://nachawati.me</uri>
        </author>
        <category label="casadi" term="casadi"/>
        <category label="wasm" term="wasm"/>
        <category label="webassembly" term="webassembly"/>
    </entry>
</feed>